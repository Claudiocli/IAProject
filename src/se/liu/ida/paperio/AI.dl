% Si aspetti come input  i fatti corrispondenti ai singoli AIPlayer e allo status delle singole Tile
% Verranno trattati come segue:
% - player(X, Y, Name, CurrentDirection, AreaSize).
%		I predicati `player(X, Y, Name, CurrentDirection, AreaSize)` sono identificati dal termine univoco
% 		`Name`, il quale sarà unico per ogni AIPlayer. `X` ed `Y` sono le coordinate del player;
%		`CurrentDirection` indica la direzione in cui si sta andando attualmente (E.g. nel caso stessi andando
%		verso sud, non potrei andare nella direzione da cui arrivo, ovvero nord); `AreaSize` è un numero che
%		identifica il numero di tiles conquistate dal player
% - tile(X, Y, Owner, ContestedOwner).
%		I predicati `tile(X, Y, Owner, ContestedOwner)` sono identificati dalla coppia dei termini (X, Y), 
%		i quali identificano la Tile in posizione (X, Y). Essa avrà, inoltre, il nome (che è identificativo)
%		dell'eventuale `Owner` (il player che l'ha conquistata) e/o dell'eventuale `ContestedOwner` (il player
%		che ci è passato sopra e la sta conquistando. Si può intendere come la "coda" del player). Di default
%		le due stringhe sopracitate sono vuote (e.g."")
% - currentPlayer(Name).
%		Il predicato indica "l'ID" del player per cui si sta analizzando la mossa migliore.
% - limiteX(XMin, XMax).
%		Il predicato indica i limiti, inferiore e superiore, cui la coordinata X dei player non può superare
% - limiteY(YMin, YMax).
%		Il predicato indica i limiti, inferiore e superiore, cui la coordinata Y dei player non può superare

% È impossibile che ci siano due player con lo stesso nome
:- player(_, _, _, N1), player(_, _, _, N2), N1=N2.

% Aggiungo alle Tile adiacenti al player solo quelle che può raggiungere (N,S,W,E), indi, eliminando a
% prescindere la direzione da cui si arriva
% Nord
adjacentTile(X, Y, C):- tile(X, Y, C), currentPlayer(XP, XY, _, _, CDir), X=XP, Y=XY-1, CDir!=south.
% Sud
adjacentTile(X, Y, C):- tile(X, Y, C), currentPlayer(XP, XY, _, _, CDir), X=XP, Y=XY+1, CDir!=north.
% Ovest
adjacentTile(X, Y, C):- tile(X, Y, C), currentPlayer(XP, XY, _, _, CDir), X=XP-1, Y=XY, CDir!=east.
% Est
adjacentTile(X, Y, C):- tile(X, Y, C), currentPlayer(XP, XY, _, _, CDir), X=XP+1, Y=XY, CDir!=west.

% Guess della next move
nextMove(X, Y) | notNextMove(X, Y):- adjacentTile(X, Y, _).

% È impossibile che la nextMove faccia oltrepassare uno dei bordi
:- nextMove(X, _), limiteXMin(XMin), XMin > X.
:- nextMove(X, _), limiteXMax(XMax), XMax < X.
:- nextMove(_, Y), limiteYMin(YMin), YMin > Y.
:- nextMove(_, Y), limiteYMax(YMax), YMax < Y.

% Si preferisce massimizzare il numero di tile contestate dal currentPlayer
% TODO: magari formulare il problema come minimizzazione con un determinato treshold

% Si preferisce massimizzare la distanza tra i diversi nemici
% TODO: minimizzare con un determinato treshold
% TODO: si potrebbe creare un altro file contenente questa parte e cambiare i valori per creare due stili,
% aggressivo e difensivo, per poi cambiarli in base alla decisione a runtime (e.g. come per variableInput)
