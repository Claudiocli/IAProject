% Si aspetti come input  i fatti corrispondenti ai singoli AIPlayer e allo status delle singole Tile
% Verranno trattati come segue: player(X, Y, Name, CurrentDirection, AreaSize).
% tile(X, Y, Owner, ContestedOwner).
% Il termine `CurrentDirection` indica la direzione in cui si sta andando attualmente.
% E.g. nel caso stessi andando verso sud, non potrei andare nella direzione da cui arrivo, ovvero nord.
% TODO: Servirebbe passare anche un currentPlayer(Name).
% I predicati `player(X, Y, Name, CurrentDirection, AreaSize)` sono identificati dal termine univoco `Name`,
% il quale sarà unico per ogni AIPlayer.
% I predicati `tile(X, Y, Owner, ContestedOwner)` sono identificati dalla coppia dei termini (X, Y), 
% i quali identificano la Tile in posizione (X, Y). Essa è cartterizzata dal  nome dell'eventuale Owner
o chi la sta contenstando.
% TODO: da aggiungere come fatto: limiteXMax(XMax). limiteYMax(YMax). - De facto delimitano i bordi
limiteXMin(0). limiteYMin(0).

% ------------------------------------ PLAYER RULES -------------------------------------

% ---> È impossibile che ci siano due player con lo stesso nome
:- player(_, _, N1, _, _), player(_, _, N2, _, _), N1=N2.
% ---> la distanza tra il player è il nemico viene calcolata dalla distanza tra la tile del player e quella dell'enemy
% in fase di sperimentazione
distanceFromPlayer(Distance, Enemey):- currentPlayer(P), player(PX, PY, P, _, _), player(EX, EY, Enemy, _, _), P!=Enemy, Distance = &abs(PX - EX) + &abs(PY - EY).

% Predicato ausiliare che identifica le eventuali "code" degli avversari che si trovano nel territorio del currentPlayer.
enemyTailTerritory(X,Y,E):- tile(X,Y,P,E), currentPlayer(P), P != E.

% ----> È preferibile diminuire la distanza tra il player e il nemico nel territorio.
:~ distanceFromPlayer(Player, DistanceX, DistanceY, Enemy),enemyTailTerritory(X,Y,Enemy),player(Px,Py,Player,_,_), contx = DistanceX - Px, conty = DistanceY - Py, final = contx + conty. [final@5]

% Aggiungo alle Tile adiacenti al player solo quelle che può raggiungere (N,S,W,E), indi, eliminando a
% prescindere la direzione da cui si arriva
% Nord
adjacentTile(X, Y, O, Co):- tile(X, Y, O, Co), player(XP, XY, Name, CDir, _), currentPlayer(Name), X=XP, Y=XY-1, CDir!=south.
% Sud
adjacentTile(X, Y, O, Co):- tile(X, Y, O, Co), player(XP, XY, Name, CDir, _), currentPlayer(Name), X=XP, Y=XY+1, CDir!=north.
% Ovest
adjacentTile(X, Y, O, Co):- tile(X, Y, O, Co), player(XP, XY, Name, CDir, _), currentPlayer(Name), X=XP-1, Y=XY, CDir!=east.
% Est
adjacentTile(X, Y, O, Co):- tile(X, Y, O, Co), player(XP, XY, Name, CDir, _), currentPlayer(Name), X=XP+1, Y=XY, CDir!=west.

% Guess della next move
nextMove(X, Y) | notNextMove(X, Y):- adjacentTile(X, Y, _).

% È impossibile che la nextMove faccia oltrepassare uno dei bordi
:- nextMove(X, _), limiteXMin(XMin), XMin > X.
:- nextMove(X, _), limiteXMax(XMax), XMax < X.
:- nextMove(_, Y), limiteYMin(YMin), YMin > Y.
:- nextMove(_, Y), limiteYMax(YMax), YMax < Y.

% ---> è impossibile che con la prossima nextmove, il player vada a intaccare la sua stessa scia.
:- nextMove(X,Y), tile(X, Y, "", Name), currentPlayer(Name).

% ------------------------------------ PASSIVE PLAYER -------------------------------------
% È preferibile ampliare il proprio territorio piuttosto che avvicinarsi ad un territorio nemico.

:~ nextMove(X,Y), tile(X,Y,"",""). [1@4]

% -----> calcolare il ritorno nella propria zona.
comeBackHome(X,Y,DistanceX,DistanceY):- player(X,Y,Player,"Est",_),player(X,Y,Player,"Ovest",_),currentPlayer(Player),nextMove(Nx,Ny),adjacentTile(Nx,Ny,V,""), Player!= Owner,DistanceX = Nx + 1,DistanceY = DistanceY + Ny.
comeBackHome(X,Y,DistanceX,DistanceY):- player(X,Y,Player,"Sud",_),player(X,Y,Player,"Nord",_),currentPlayer(Player),nextMove(Nx,Ny),adjacentTile(Nx,Ny,V,""), Player!= Owner,DistanceX = Nx + DistanceX,DistanceY = Ny + 1.


------------------------------------------- REVISIONE TOTALE ---------------------------------------------------



% -----> la distanza totale non è altro che l'ultima Distanza calcolata dal comeBackHome.
totalDistance(DistX,DistY):- #max{DistanceX: comeBackHome(_,_,DistanceX,_)}= DistX,#max{DistanceY: comeBackHome(_,_,_,DistanceY)} = DistY.

%se la distanza tra il player in scia e il nemico è troppo corta ci troviamo in zona di pericolo
WarningDistance(DistX,DistY):- distanceFromPlayer(Player,DistX,DistY,Enemy),totalDistance(DistanceX,DistanceY),contX = DistX-DistanceX, contY= DistY - DistanceY,contX<=DistanceX, contY<=DistanceY.

:-WarningDistance(X,Y),nextMove(Nx,Ny),X>Nx, Y>Ny.

%POTREI AVER SCRITTO UN MUCCHIO DI CAGATE.

--------------------------------------------------FINE-------------------------------------------------------------




% :~ nextMove(Px,Py), enemyTailTerritory(X, Y, Enemy), Dist = &distance(X,Y,Px,Py). [Dist@1]

% Si preferisce massimizzare il numero di tile contestate dal currentPlayer
% TODO: magari formulare il problema come minimizzazione con un determinato treshold

% Si preferisce massimizzare la distanza tra i diversi nemici
% TODO: minimizzare con un determinato treshold
% TODO: si potrebbe creare un altro file contenente questa parte e cambiare i valori per creare due stili,
% aggressivo e difensivo, per poi cambiarli in base alla decisione a runtime (e.g. come per variableInput)
